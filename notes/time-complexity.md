# 시간 복잡도 가이드

## 입력 크기와 시간 복잡도

| N | 알고리즘 | 예시 |
|---|---------|------|
| N ≤ 11 | O(N!) | 순열 전체 탐색 |
| N ≤ 25 | O(2^N) | 비트마스킹, 부분집합 |
| N ≤ 100 | O(N^4) | DP 4중 for문 |
| N ≤ 500 | O(N^3) | 플로이드-워셜, DP 3중 for문 |
| N ≤ 3,000 | O(N^2 log N) | 정렬 + 이중 for문 |
| N ≤ 5,000 | O(N^2) | 이중 for문 |
| N ≤ 100,000 | O(N log N) | 정렬, 우선순위 큐 |
| N ≤ 10,000,000 | O(N) | 선형 탐색, 투 포인터 |

## Python 시간 제한 고려

- Python은 C++보다 5~10배 느림
- PyPy3가 일반 Python3보다 빠른 경우 많음
- 입력이 많으면 `sys.stdin.readline` 필수

## 자주 쓰는 연산 복잡도

### 정렬
- 기본 정렬: O(N log N)
- 계수 정렬: O(N + K)

### 탐색
- 선형 탐색: O(N)
- 이진 탐색: O(log N)
- 해시: O(1) 평균

### 그래프
- DFS/BFS: O(V + E)
- 다익스트라: O((V + E) log V)
- 벨만-포드: O(VE)
- 플로이드-워셜: O(V^3)

### 자료구조
- 리스트 접근: O(1)
- 리스트 삽입/삭제: O(N)
- 딕셔너리 접근: O(1) 평균
- 힙 삽입/삭제: O(log N)

## 최적화 팁

1. **불필요한 연산 제거**: 중복 계산 피하기
2. **조기 종료**: 조건 만족시 바로 리턴
3. **자료구조 선택**: set/dict 활용
4. **입출력 최적화**: sys.stdin.readline
5. **메모이제이션**: 재귀 결과 캐싱

