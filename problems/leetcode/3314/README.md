---
problem_id: 3314
title: Construct the Minimum Vitwise Array1
source: leetcode
url: https://leetcode.com/problems/3314
difficulty: easy
algorithms: [array]
companies: []
solved: false
solved_date: null
retry_count: 0
time_complexity: ""
space_complexity: ""
---

# Construct the Minimum Vitwise Array1

## 문제
You are given an array nums consisting of n prime integers.
소수 정수로 이루어진 nums 배열이 주어진다.

You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].
길이 n 인 ans 배열을 만들어야 하며, 각 인덱스 i에 대해서 ans[i]와 ans[i] + 1 비트 OR 연산 결과가 nums[i]와 같아야 한다.

Additionally, you must minimize each value of ans[i] in the resulting array.
추가 적으로, ans[i]의 값을 최소화 해야 한다.

If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.
만약 ans[i]의 만족하는 값을 찾을 수 없다면, ans[i] = -1로 설정한다.

## 입력
- 1 <= nums.length <= 100
- 2 <= nums[i] <= 1000
- nums[i] is a prime number.

## 출력
<!-- 출력 형식 -->

## 예제

### 입력 1
```python
nums = [2,3,5,7]
```

### 출력 1
```python
ans = [-1,1,4,3]
# For i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.
# For i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.
# For i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.
# For i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.
```

### 입력 2
```python
nums = [11,13,31]
```

### 출력 2
```python
ans = [9,12,15]
# For i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.
# For i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.
# For i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.
```
## 풀이

### 접근
이 문제는 `ans[i] | (ans[i] + 1) == nums[i]`를 만족하는 가장 작은 `ans[i]`를 찾는 문제다. 비트 연산의 특성을 이용하면 효율적으로 풀 수 있다.

#### 1. `x | (x + 1)` 연산의 특성
이진수에서 어떤 수 `x`에 1을 더하면 다음과 같은 변화가 일어난다.
- 가장 오른쪽에 있는 `0`이 `1`로 변한다. (올림이 발생하는 지점)
- 그 `0`보다 오른쪽에 있던 모든 `1`들은 `0`으로 변한다.
- **예:** `x = 11 (1011₂)` -> `x + 1 = 12 (1100₂)`

이때 두 수를 **OR 연산(`|`)** 하면 어떻게 될까?
- 원래 `x`가 가지고 있던 비트들에 더해, `x+1` 과정에서 `1`로 변한 비트까지 포함하게 된다.
- 결과적으로 **"가장 오른쪽에 있던 0 하나가 1로 채워지는 효과"**가 나타난다.
- **예:** `1011 | 1100 = 1111` (오른쪽 끝에서 두 번째에 있던 0이 1로 채워짐)

#### 2. 역발상: `nums[i]`에서 `ans[i]` 찾기
`ans | (ans + 1) == nums`라는 것은, `nums`는 `ans`에서 0 하나를 1로 바꾼 결과라는 뜻이다.
반대로 생각하면, `nums`에서 어떤 비트 하나를 꺼서 `ans`를 만들 수 있다는 뜻인데, 아무 비트나 끌 수 있는 게 아니라 **"1을 더했을 때 올림이 발생해서 다시 그 자리를 채울 수 있는 비트"**여야 한다.

이런 비트들은 `nums`의 **오른쪽 끝에서부터 연속된 1들**이다.

#### 3. 최솟값 찾기
가장 작은 `ans`를 만들려면, **가장 높은 자리(왼쪽)의 비트를 꺼야 한다.**
- **예:** `nums = 7 (0111₂)`
    - 후보 1: `0110 (6)` -> `6|7 = 7`
    - 후보 2: `0101 (5)` -> `5|6 = 7`
    - 후보 3: `0011 (3)` -> `3|4 = 7` (최솟값!)

따라서, `nums[i]`의 오른쪽 끝에서부터 연속된 1의 덩어리를 찾고, 그 중 가장 상위 비트를 0으로 만든 값이 정답이 된다.

### 시간 복잡도
- `nums`의 길이를 $N$, 숫자의 비트 길이를 $B$라고 할 때, $O(N \times B)$
- $B$는 최대 10 ($2^{10} = 1024$) 정도로 매우 작으므로 효율적이다.


## 회고
- prime integer : 소수
- bitwise OR : 비트 OR 연산


### 비트 연산 종류
- AND : &
- OR : |
- XOR : ^
- NOT : ~
- SHIFT LEFT : <<
- SHIFT RIGHT : >>

### 비트 OR 연산이란
- 비트 OR 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 둘 중 하나라도 1이면 1
    - 둘 다 0이면 0
```python
# 예시
a = 5 # -> 0101
b = 3 # -> 0011
# a | b = 0111 # -> 7
```
### 비트 AND 연산이란
- 비트 AND 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 둘 다 1이면 1
    - 둘 중 하나라도 0이면 0
```python
# 예시
a = 5 # -> 0101
b = 3 # -> 0011
# a & b = 0001 # -> 1
```

### 비트 XOR 연산이란
- 비트 XOR 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 둘 다 1이면 0
    - 둘 중 하나라도 0이면 1
```python
# 예시
a = 5 # -> 0101
b = 3 # -> 0011
# a ^ b = 0110 # -> 6
```

### 비트 NOT 연산이란
- 비트 NOT 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 1이면 0
    - 0이면 1
```python
# 예시
a = 5 # -> 0101
# ~a = 1010 # -> 10
```

### 비트 SHIFT LEFT 연산이란
- 비트 SHIFT LEFT 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 왼쪽으로 1칸 이동
    - 오른쪽으로 1칸 이동
```python
# 예시
a = 5 # -> 0101
# a << 1 = 1010 # -> 10
```

### 비트 SHIFT RIGHT 연산이란
- 비트 SHIFT RIGHT 연산은 두 숫자를 이진수로 변환해서 각 비트 위치마다 다음 규칙으로 게산하는 것이다.
    - 오른쪽으로 1칸 이동
    - 왼쪽으로 1칸 이동
```python
# 예시
a = 5 # -> 0101
# a >> 1 = 0010 # -> 2
```

## 1. 비트 연산의 특성: x | (x + 1)
어떤 수 x에 1을 더하면, 가장 오른쪽에 있는 0이 1로 바뀌고, 그보다 오른쪽에 있던 1들은 모두 0이 돼.
- 예: x = 11(1011₂) -> x + 1 = 12(1100₂)
- 이때 x | (x + 1)을 하면? 1011 | 1100 = 1111
- 즉, x | (x + 1)은 x의 가장 오른쪽 0을 1로 바꾸는 연산과 같아.

## 2. 문제 해결의 역발상
- ans[i] | (ans[i] + 1) == nums[i]라는 건, nums[i]에서 연속된 오른쪽 1들 중 하나를 0으로 만들었을 때 그게 바로 ans[i]가 된다는 뜻이야.
- 가장 작은 ans[i]를 찾으려면, nums[i]의 가장 하위 비트(LSB)부터 시작해서 연속된 1의 덩어리 중 가장 높은 자리의 비트를 0으로 만들어줘야 해.

## 3. 코드 한 줄씩 뜯어보기
```python
35| for i in range(len(nums)):
36|     res = -1      # 초기값은 -1 (조건 만족 못할 경우 대비)
37|     d = 1         # 현재 확인 중인 비트 위치 (1, 2, 4, 8...)
38|     while (nums[i] & d) != 0:  # nums[i]의 d 위치 비트가 1인 동안 반복
39|         res = nums[i] - d      # d 위치의 1을 0으로 바꿔봄 (이게 후보 ans)
40|         d <<= 1                # 다음 비트 위치로 이동
41|     nums[i] = res              # 가장 마지막에 찾은(가장 큰 d를 뺀) 값이 최솟값
```

예시: nums[i] = 7 (0111₂)
- 초기: d = 1, res = -1
- 1회전: 7 & 1 != 0 참. res = 7 - 1 = 6 (0110₂), d = 2
- 2회전: 7 & 2 != 0 참. res = 7 - 2 = 5 (0101₂), d = 4
- 3회전: 7 & 4 != 0 참. res = 7 - 4 = 3 (0011₂), d = 8
- 종료: 7 & 8 == 0 루프 탈출.
- 결과: nums[i] = 3. (실제로 3 | 4 = 7 이고, 3이 가장 작은 값이야.)


예시: nums[i] = 10 (1010₂)
- 초기: d = 1, res = -1
- 1회전: 10 & 1 == 0 루프 시작도 못 함.
- 결과: nums[i] = -1. (x | x+1은 무조건 홀수여야 하므로 짝수인 10은 답이 없음.)


요약
- 이 코드는 nums[i]의 오른쪽 끝에서부터 연속된 1의 개수를 세면서, 그 1들을 하나씩 꺼보며 후보를 찾고 - 있어.
- 루프가 돌수록 더 큰 자리수(d)의 1을 끄기 때문에, res는 점점 작아지고 결국 최솟값이 남게 돼.
- 만약 nums[i]가 짝수면 루프를 안 타니까 바로 -1이 리턴되는 깔끔한 구조지.

더 효율적으로 짜고 싶다면 루프 없이 nums[i] & (nums[i] + 1) 같은 트릭을 쓸 수도 있지만, 이 방식이 직관적이고 가독성은 좋아.

## 1. x | (x + 1)은 왜 "오른쪽 끝 0을 1로 채우는가?

이진수 계산의 핵심은 올림(Carry)이야. 1을 더하면 어떤 일이 벌어지는지 봐봐.

- 예시: x = 11 (1011₂)
- 가장 오른쪽 비트가 1이지? 여기에 1을 더하면 0이 되고 앞자리로 올림이 발생해.
- 그 앞자리도 1이면 또 0이 되고 또 올림이 발생해.
- 그러다가 처음으로 0을 만나는 순간, 그 0이 1로 바뀌면서 올림이 멈춰.
- 1011 + 1 = 1100 (뒤의 11이 00이 되고, 그 앞의 0이 1이 됨)
- 이제 OR 연산(|)을 해보자:
```
    x     : 1 0 1 1  (기존 수)    
    x + 1 : 1 1 0 0  (0을 1로 바꾸고 그 뒤를 다 0으로 만든 수)    
    ----------------    
    OR 결과: 1 1 1 1  (원래 0이었던 자리가 1로 채워짐)
```
- 결과적으로 "가장 오른쪽에 있던 0 하나가 1로 변한 효과"가 나타나는 거야.

## 2. 왜 nums[i]의 1들 중 하나를 0으로 바꾸면 ans[i]가 되는가?
위의 원리를 거꾸로 생각해보자.
- 우리는 ans | (ans + 1) == nums인 ans를 찾아야 해.
- 이 말은 "nums는 ans에서 0 하나를 1로 바꾼 결과물이다"라는 뜻과 같아.
- 그럼 nums에서 어떤 1을 0으로 바꿔야 ans가 될까? 아무 1이나 바꾼다고 되는 게 아냐. 반드시 1을 더했을 때 올림이 발생해서 그 자리를 다시 채울 수 있는 위치여야 해.
- 그 위치가 어디냐? 바로 오른쪽 끝에서부터 연속된 1들 중 하나야.
- 예시: nums = 7 (0111₂)
- 오른쪽 끝에 1이 세 개(2², 2¹, 2⁰ 자리) 연속되어 있지? 이 중 하나가 원래 0이었다는 뜻이야.
- 2⁰ 자리가 0이었다면? ans = 0110 (6). 6 | 7 = 7 (O)
- 2¹ 자리가 0이었다면? ans = 0101 (5). 5 | 6 = 7 (O)
- 2² 자리가 0이었다면? ans = 0011 (3). 3 | 4 = 7 (O)


## 3. 왜 "가장 높은 자리의 비트"를 0으로 만드는 게 "가장 작은 ans"인가?
위의 nums = 7 예시를 다시 봐봐.
- 후보 1: 0110 (6)
- 후보 2: 0101 (5)
- 후보 3: 0011 (3)


우리는 가장 작은 ans를 찾아야 해. 숫자를 작게 만들려면 높은 자리수(왼쪽)에 있는 1을 0으로 바꿀수록 숫자가 확 줄어들겠지?


그래서 코드에서는 while 문을 돌면서 오른쪽 끝(d=1)부터 시작해서 1인 동안 계속 res = nums[i] - d를 업데이트하는 거야. 루프가 마지막까지 돌면 연속된 1들 중 가장 높은 자리의 1을 뺀 값이 res에 남게 되고, 그게 바로 최솟값이 되는 거지.


## 요약하자면:
- ans에 1을 더하면 가장 오른쪽 0이 1로 바뀐다.
- ans | (ans + 1)은 그 자리를 1로 메꾼 결과다.
- 따라서 nums에서 오른쪽 연속된 1 중 가장 왼쪽 것을 0으로 바꾸면, 그게 1을 더했을 때 가장 크게 변하는 지점이고, 결과적으로 가장 작은 원래 숫자(ans)를 찾게 된다.
- 이제 이 코드가 왜 while 문을 돌면서 d를 계속 키우는지 이해가 될 거야. 가장 높은 자리의 1을 찾아서 제거하려고 하는 거지.